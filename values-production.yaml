# =============================================================================
# EdgeQuota — Production-Ready Values
# =============================================================================
# Rock-solid configuration with HA, autoscaling, TLS, monitoring, security
# hardening, and network policies.
#
# Prerequisites:
#   - Redis Sentinel or Cluster deployed and reachable.
#   - cert-manager installed with a ClusterIssuer named "letsencrypt-prod".
#   - prometheus-operator (kube-prometheus-stack) installed for ServiceMonitor.
#   - An existing Kubernetes Secret with Redis credentials:
#       kubectl create secret generic edgequota-redis-creds \
#         --from-literal=redis-password='<PASSWORD>' \
#         --from-literal=redis-sentinel-password='<SENTINEL_PASSWORD>'
#
# Usage:
#   helm install edgequota ./edgequota-helm \
#     -n edgequota --create-namespace \
#     -f values-production.yaml
# =============================================================================

# =============================================================================
# Replicas — baseline for HPA
# =============================================================================
replicaCount: 3

# =============================================================================
# Image
# =============================================================================
image:
  registry: ""
  repository: ghcr.io/shoro-io/edgequota
  tag: ""  # pinned to Chart.appVersion
  pullPolicy: IfNotPresent

# =============================================================================
# Deployment Strategy
# =============================================================================
deployment:
  revisionHistoryLimit: 5
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0

# =============================================================================
# Service Account & RBAC
# =============================================================================
serviceAccount:
  create: true
  automountServiceAccountToken: false

rbac:
  create: true

# =============================================================================
# Pod Security — hardened
# =============================================================================
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 65534
  runAsGroup: 65534
  fsGroup: 65534
  seccompProfile:
    type: RuntimeDefault

containerSecurityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  capabilities:
    drop:
      - ALL

terminationGracePeriodSeconds: 60

# -- Use a high-priority class to ensure edgequota pods are scheduled first
# priorityClassName: system-cluster-critical

# =============================================================================
# Resources — sized for production traffic
# =============================================================================
resources:
  requests:
    cpu: 500m
    memory: 128Mi
  limits:
    memory: 512Mi

# =============================================================================
# Probes — tuned for production
# =============================================================================
startupProbe:
  initialDelaySeconds: 1
  periodSeconds: 2
  timeoutSeconds: 3
  failureThreshold: 30
  successThreshold: 1

livenessProbe:
  initialDelaySeconds: 0
  periodSeconds: 15
  timeoutSeconds: 5
  failureThreshold: 3
  successThreshold: 1

readinessProbe:
  initialDelaySeconds: 0
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3
  successThreshold: 1

# =============================================================================
# Service
# =============================================================================
# Proxy service port is auto-derived: 80 (no TLS) or 443 (TLS).
# Admin service is always ClusterIP on the admin container port.
service:
  type: ClusterIP

# =============================================================================
# Ingress — with cert-manager TLS termination
# =============================================================================
ingress:
  enabled: true
  className: nginx
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/proxy-body-size: "0"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
    # Preserve client IP behind the ingress
    nginx.ingress.kubernetes.io/use-forwarded-headers: "true"
  hosts:
    - host: edgequota.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: edgequota-ingress-tls
      hosts:
        - edgequota.example.com

# =============================================================================
# Certificate — cert-manager for proxy-level TLS (optional, for end-to-end TLS)
# =============================================================================
# Enable this if you want TLS termination at the EdgeQuota pod itself
# (e.g., running EdgeQuota as a LoadBalancer service without an ingress).
# When using Ingress TLS termination, you typically don't need this.
certificate:
  enabled: false
  # issuerRef:
  #   name: letsencrypt-prod
  #   kind: ClusterIssuer
  # dnsNames:
  #   - edgequota.example.com
  # privateKey:
  #   algorithm: ECDSA
  #   size: 256

# =============================================================================
# Vertical Pod Autoscaler — recommendation-only alongside HPA
# =============================================================================
# Requires the VPA CRD (autoscaling.k8s.io/v1) to be installed.
# updateMode "Off" means VPA will only provide resource recommendations
# without mutating pods — HPA handles the actual scaling.
verticalPodAutoscaler:
  enabled: true
  updateMode: "Off"
  containerPolicies:
    - containerName: "*"
      minAllowed:
        cpu: 100m
        memory: 64Mi
      maxAllowed:
        cpu: "4"
        memory: 4Gi
      controlledResources: ["cpu", "memory"]

# =============================================================================
# Autoscaling (HPA)
# =============================================================================
autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 15
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
        - type: Percent
          value: 10
          periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 30
      policies:
        - type: Percent
          value: 50
          periodSeconds: 60
        - type: Pods
          value: 4
          periodSeconds: 60
      selectPolicy: Max

# =============================================================================
# Pod Disruption Budget
# =============================================================================
podDisruptionBudget:
  enabled: true
  maxUnavailable: 1

# =============================================================================
# Metrics & Monitoring
# =============================================================================
metrics:
  enabled: true
  serviceMonitor:
    enabled: true
    interval: "15s"
    scrapeTimeout: "10s"

# =============================================================================
# Network Policy
# =============================================================================
networkPolicy:
  enabled: true
  # Allow proxy traffic from any source (ingress controller, other namespaces)
  ingressFrom:
    - namespaceSelector: {}
  # Allow admin/metrics only from monitoring namespace
  adminFrom:
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: monitoring
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: kube-system
  # Redis egress — adjust namespace/labels to match your Redis deployment
  redisEgress:
    ports:
      - port: 6379
        protocol: TCP
      - port: 26379
        protocol: TCP
    to:
      - namespaceSelector: {}
  # Backend egress — adjust to your backend's location
  backendEgress:
    ports:
      - port: 8080
        protocol: TCP
      - port: 443
        protocol: TCP
    to:
      - namespaceSelector: {}

# =============================================================================
# Secrets — use existing secret for Redis credentials
# =============================================================================
secrets:
  create: false
  existingSecret: "edgequota-redis-creds"
  existingSecretMappings:
    - envVar: EDGEQUOTA_REDIS_PASSWORD
      key: redis-password
    - envVar: EDGEQUOTA_REDIS_SENTINEL_PASSWORD
      key: redis-sentinel-password

# =============================================================================
# Scheduling — multi-AZ spread
# =============================================================================
topologySpreadConstraints:
  - maxSkew: 1
    topologyKey: topology.kubernetes.io/zone
    whenUnsatisfiable: ScheduleAnyway
    labelSelector:
      matchLabels:
        app.kubernetes.io/name: edgequota
  - maxSkew: 1
    topologyKey: kubernetes.io/hostname
    whenUnsatisfiable: DoNotSchedule
    labelSelector:
      matchLabels:
        app.kubernetes.io/name: edgequota

affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values:
                  - edgequota
          topologyKey: kubernetes.io/hostname

# =============================================================================
# EdgeQuota Application Configuration
# =============================================================================
edgequota:
  server:
    port: 8080
    readTimeout: "30s"
    writeTimeout: "30s"
    idleTimeout: "120s"
    drainTimeout: "30s"
    requestTimeout: "60s"
    tls:
      enabled: false  # TLS terminated at ingress in this example

  admin:
    port: 9090
    readTimeout: "5s"
    writeTimeout: "10s"
    idleTimeout: "30s"

  backend:
    url: "http://my-backend-service.default.svc.cluster.local:8080"
    timeout: "30s"
    maxIdleConns: 200
    idleConnTimeout: "90s"
    maxRequestBodySize: 10485760  # 10 MiB
    transport:
      dialTimeout: "10s"
      dialKeepAlive: "30s"
      tlsHandshakeTimeout: "10s"
      h2ReadIdleTimeout: "30s"
      h2PingTimeout: "15s"
    urlPolicy:
      denyPrivateNetworks: true

  redis:
    endpoints:
      - "redis-node-0.redis-headless:26379"
      - "redis-node-1.redis-headless:26379"
      - "redis-node-2.redis-headless:26379"
    mode: "sentinel"
    masterName: "mymaster"
    db: 0
    poolSize: 50
    dialTimeout: "5s"
    readTimeout: "3s"
    writeTimeout: "3s"
    tls:
      enabled: false

  rateLimit:
    average: 1000
    burst: 100
    period: "1s"
    failurePolicy: "inMemoryFallback"
    failureCode: 429
    maxRecoveryAttempts: 20
    keyStrategy:
      type: "clientIP"
      trustedProxies:
        - "10.0.0.0/8"
        - "172.16.0.0/12"
        - "192.168.0.0/16"
      trustedIPDepth: 1

    # -- External rate-limit service (uncomment to enable)
    # external:
    #   enabled: true
    #   timeout: "3s"
    #   cacheTTL: "30s"
    #   http:
    #     url: "http://rl-service.default:8080/limits"
    #   maxConcurrentRequests: 100
    #   circuitBreaker:
    #     threshold: 5
    #     resetTimeout: "30s"

  # -- Auth (uncomment to enable)
  # auth:
  #   enabled: true
  #   timeout: "5s"
  #   failurePolicy: "failclosed"
  #   http:
  #     url: "http://auth-service.default:8080/check"
  #   circuitBreaker:
  #     threshold: 5
  #     resetTimeout: "30s"

  # -- Events (uncomment to enable)
  # events:
  #   enabled: true
  #   http:
  #     url: "http://events-service.default:8080/publish"
  #   batchSize: 100
  #   flushInterval: "5s"
  #   bufferSize: 10000

  logging:
    level: "info"
    format: "json"

  tracing:
    enabled: true
    endpoint: "http://otel-collector.observability:4318"
    serviceName: "edgequota"
    sampleRate: 0.05
