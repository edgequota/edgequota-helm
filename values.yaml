# =============================================================================
# EdgeQuota Helm Chart - Default Values
# =============================================================================
# This file contains ALL configurable values with sensible defaults.
# Override with values-minimal.yaml or values-production.yaml as a starting point.
# =============================================================================

# -- Override the chart name
nameOverride: ""
# -- Override the full release name
fullnameOverride: ""
# -- Labels applied to all resources
commonLabels: {}

# =============================================================================
# Image
# =============================================================================
image:
  # -- Container image registry (leave empty if repository includes registry)
  registry: ""
  # -- Container image repository
  repository: ghcr.io/edgequota/edgequota
  # -- Container image tag (defaults to Chart.appVersion)
  tag: ""
  # -- Image pull policy
  pullPolicy: IfNotPresent

# -- Image pull secrets for private registries
imagePullSecrets: []
# - name: my-registry-secret

# =============================================================================
# Replicas
# =============================================================================
# -- Number of replicas (ignored if autoscaling.enabled=true)
replicaCount: 1

# =============================================================================
# Deployment
# =============================================================================
deployment:
  # -- Annotations added to the Deployment resource
  annotations: {}
  # -- Number of old ReplicaSets to retain
  revisionHistoryLimit: 5
  # -- Deployment update strategy
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0

# =============================================================================
# Service Account & RBAC
# =============================================================================
serviceAccount:
  # -- Create a ServiceAccount
  create: true
  # -- ServiceAccount name (auto-generated if empty)
  name: ""
  # -- Annotations for the ServiceAccount (e.g., for IAM roles)
  annotations: {}
  # -- Mount the service account token in the pod
  automountServiceAccountToken: false

rbac:
  # -- Create Role and RoleBinding
  create: true
  # -- Custom rules (overrides the default configmap-read rule)
  rules: []

# =============================================================================
# Pod Configuration
# =============================================================================
# -- Labels added to pods
podLabels: {}
# -- Annotations added to pods
podAnnotations: {}

# -- Pod security context (applied to the pod)
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 65534
  runAsGroup: 65534
  fsGroup: 65534
  seccompProfile:
    type: RuntimeDefault

# -- Pod-level sysctls (rendered into securityContext.sysctls).
# This is one of the options for raising the kernel UDP buffer limits
# required by HTTP/3 backend traffic (backendProtocol: "h3"). See the
# "HTTP/3 backend — UDP buffer prerequisites" section below initContainers
# for a full explanation of the problem and all available solutions.
#
# net.core.rmem_max and net.core.wmem_max are namespaced sysctls, but
# Kubernetes considers them "unsafe". To use this approach, the kubelet on
# every node that schedules EdgeQuota pods must be started with:
#   --allowed-unsafe-sysctls=net.core.rmem_max,net.core.wmem_max
# Without this flag, the pod will be rejected by the kubelet at admission.
#
# If your cluster does not allow unsafe sysctls, use the initContainers
# approach instead (see below).
#
# Example:
#   sysctls:
#     net.core.rmem_max: "7500000"
#     net.core.wmem_max: "7500000"
sysctls: {}

# -- Container security context (applied to the edgequota container)
containerSecurityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  capabilities:
    drop:
      - ALL

# -- Termination grace period (should be >= drain_timeout + buffer)
terminationGracePeriodSeconds: 60

# -- Priority class name for pod scheduling priority
priorityClassName: ""

# -- DNS policy for the pod
dnsPolicy: ""
# -- Custom DNS configuration
dnsConfig: {}

# =============================================================================
# Resources
# =============================================================================
resources:
  requests:
    cpu: 100m
    memory: 64Mi
  limits:
    memory: 256Mi

# =============================================================================
# Probes
# =============================================================================
startupProbe:
  initialDelaySeconds: 1
  periodSeconds: 2
  timeoutSeconds: 3
  failureThreshold: 30
  successThreshold: 1

livenessProbe:
  initialDelaySeconds: 0
  periodSeconds: 10
  timeoutSeconds: 3
  failureThreshold: 3
  successThreshold: 1

readinessProbe:
  initialDelaySeconds: 0
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3
  successThreshold: 1

# =============================================================================
# Service
# =============================================================================
# The chart creates two services:
#   1. Proxy service — port 80 (no TLS) or 443 (TLS) → container port 8080.
#      Type and LB options are configurable below.
#   2. Admin service — always ClusterIP on the admin container port (default 9090).
#      Serves health probes, readiness, and Prometheus metrics.
service:
  # -- Proxy service type: ClusterIP, NodePort, LoadBalancer
  type: ClusterIP
  # -- Annotations for the proxy Service (e.g., for cloud LB configuration)
  annotations: {}
  # -- Annotations for the admin Service
  adminAnnotations: {}
  # -- Explicit cluster IP (set to "None" for headless)
  clusterIP: ""
  # -- Load balancer IP (cloud-specific)
  loadBalancerIP: ""
  # -- Restrict LB source ranges
  loadBalancerSourceRanges: []
  # -- External traffic policy: Cluster or Local
  externalTrafficPolicy: ""
  # -- NodePort value (only used when type=NodePort)
  nodePort: ""
  # -- IP family policy: SingleStack, PreferDualStack, RequireDualStack
  ipFamilyPolicy: ""
  # -- IP families
  ipFamilies: []

# =============================================================================
# Ingress
# =============================================================================
ingress:
  # -- Enable Ingress
  enabled: false
  # -- Ingress class name
  className: ""
  # -- Ingress annotations
  annotations: {}
  # Example for cert-manager + nginx:
  #   cert-manager.io/cluster-issuer: letsencrypt-prod
  #   nginx.ingress.kubernetes.io/ssl-redirect: "true"
  #   nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
  # -- Ingress hosts
  hosts: []
  # - host: edgequota.example.com
  #   paths:
  #     - path: /
  #       pathType: Prefix
  # -- Ingress TLS configuration
  tls: []
  # - secretName: edgequota-tls
  #   hosts:
  #     - edgequota.example.com

# =============================================================================
# Certificate (cert-manager)
# =============================================================================
certificate:
  # -- Create a cert-manager Certificate resource
  enabled: false
  # -- Annotations on the Certificate
  annotations: {}
  # -- Secret name for the generated TLS cert (defaults to <fullname>-tls)
  secretName: ""
  # -- Certificate duration
  duration: "2160h"  # 90 days
  # -- Renew before expiration
  renewBefore: "360h"  # 15 days
  # -- Issuer reference
  issuerRef:
    name: ""
    kind: ClusterIssuer
    group: ""
  # -- Common name
  commonName: ""
  # -- DNS names for the certificate
  dnsNames: []
  # -- IP addresses for the certificate
  ipAddresses: []
  # -- Private key configuration
  privateKey:
    algorithm: ECDSA
    size: 256

# =============================================================================
# Vertical Pod Autoscaler (VPA)
# =============================================================================
# Requires the VPA CRD (autoscaling.k8s.io/v1) to be installed.
verticalPodAutoscaler:
  # -- Enable Vertical Pod Autoscaler
  enabled: false
  # -- Update mode: Auto, Recreate, or Off
  updateMode: "Auto"
  # -- Container-level resource policies
  containerPolicies:
    - containerName: "*"
      minAllowed:
        cpu: 50m
        memory: 64Mi
      maxAllowed:
        cpu: "2"
        memory: 2Gi
      controlledResources: ["cpu", "memory"]

# =============================================================================
# Autoscaling (HPA)
# =============================================================================
autoscaling:
  # -- Enable Horizontal Pod Autoscaler
  enabled: false
  # -- Minimum replicas
  minReplicas: 3
  # -- Maximum replicas
  maxReplicas: 10
  # -- Target CPU utilization percentage
  targetCPUUtilizationPercentage: 70
  # -- Target memory utilization percentage
  targetMemoryUtilizationPercentage: ""
  # -- Custom metrics for scaling
  customMetrics: []
  # -- HPA scaling behavior
  behavior: {}
  # -- Annotations on the HPA
  annotations: {}

# =============================================================================
# Pod Disruption Budget
# =============================================================================
podDisruptionBudget:
  # -- Enable PDB
  enabled: false
  # -- Minimum available pods (mutually exclusive with maxUnavailable)
  minAvailable: ""
  # -- Maximum unavailable pods
  maxUnavailable: 1
  # -- Unhealthy pod eviction policy (AlwaysAllow or IfHealthy)
  unhealthyPodEvictionPolicy: ""

# =============================================================================
# Metrics & Monitoring
# =============================================================================
metrics:
  # -- Enable Prometheus annotations on pods
  enabled: true
  serviceMonitor:
    # -- Create a ServiceMonitor resource (requires prometheus-operator CRDs)
    enabled: false
    # -- Namespace for the ServiceMonitor (defaults to release namespace)
    namespace: ""
    # -- Additional labels for the ServiceMonitor
    labels: {}
    # -- Annotations on the ServiceMonitor
    annotations: {}
    # -- Scrape interval
    interval: "30s"
    # -- Scrape timeout
    scrapeTimeout: "10s"
    # -- Honor labels from the target
    honorLabels: false
    # -- Metric relabelings
    metricRelabelings: []
    # -- Relabelings
    relabelings: []

# =============================================================================
# Network Policy
# =============================================================================
networkPolicy:
  # -- Enable NetworkPolicy
  enabled: false
  # -- Sources allowed to reach the proxy port
  ingressFrom: []
  # Example: allow from any namespace
  # - namespaceSelector: {}
  # -- Sources allowed to reach the admin port
  adminFrom: []
  # Example: allow only monitoring namespace
  # - namespaceSelector:
  #     matchLabels:
  #       kubernetes.io/metadata.name: monitoring
  # -- Egress rule for Redis
  redisEgress: {}
  # Example:
  #   ports:
  #     - port: 6379
  #       protocol: TCP
  #   to:
  #     - namespaceSelector:
  #         matchLabels:
  #           kubernetes.io/metadata.name: redis
  # -- Egress rule for backend
  backendEgress: {}
  # -- Additional egress rules
  extraEgress: []

# =============================================================================
# Secrets
# =============================================================================
secrets:
  # -- Create a Secret resource with Redis credentials
  create: false
  # -- Annotations on the Secret
  annotations: {}
  # -- Use an existing secret instead of creating one
  existingSecret: ""
  # -- Mappings from existing secret keys to env vars (when using existingSecret)
  existingSecretMappings: []
  # - envVar: EDGEQUOTA_REDIS_PASSWORD
  #   key: redis-password
  # -- Redis password
  redisPassword: ""
  # -- Redis username
  redisUsername: ""
  # -- Redis Sentinel password
  redisSentinelPassword: ""
  # -- Redis Sentinel username
  redisSentinelUsername: ""
  # -- Cache Redis password
  cacheRedisPassword: ""
  # -- Cache Redis username
  cacheRedisUsername: ""
  # -- Cache Redis Sentinel password
  cacheRedisSentinelPassword: ""
  # -- Cache Redis Sentinel username
  cacheRedisSentinelUsername: ""
  # -- Response Cache Redis password (for dedicated response_cache_redis)
  responseCacheRedisPassword: ""
  # -- Response Cache Redis username
  responseCacheRedisUsername: ""
  # -- Response Cache Redis Sentinel password
  responseCacheRedisSentinelPassword: ""
  # -- Response Cache Redis Sentinel username
  responseCacheRedisSentinelUsername: ""
  # -- Extra key-value pairs to include in the Secret
  extra: {}

# =============================================================================
# Scheduling
# =============================================================================
# -- Node selector
nodeSelector: {}
# -- Tolerations
tolerations: []
# -- Affinity rules
affinity: {}
# -- Topology spread constraints
topologySpreadConstraints: []

# =============================================================================
# Extra / Escape Hatches
# =============================================================================
# -- Extra command-line arguments passed to the edgequota binary
extraArgs: []
# -- Extra environment variables
extraEnv: []
# -- Extra envFrom sources (ConfigMaps, Secrets)
extraEnvFrom: []
# -- Extra volume mounts for the edgequota container
extraVolumeMounts: []
# -- Extra volumes
extraVolumes: []
# -- Init containers (list of complete container specs).
#
# ============================================================================
# HTTP/3 backend — UDP buffer prerequisites
# ============================================================================
# When backendProtocol is set to "h3", EdgeQuota uses quic-go to speak
# HTTP/3 (QUIC) to the upstream backend over UDP. quic-go requires the
# kernel UDP receive buffer (net.core.rmem_max) to be at least 7168 KiB
# (~7 MiB / 7340032 bytes). If the limit is too low, you will see this
# log line at startup:
#
#   "failed to sufficiently increase receive buffer size
#    (was: 208 kiB, wanted: 7168 kiB, got: 416 kiB)"
#
# and every QUIC connection to the backend will time out after 5 seconds,
# producing 502 errors. This happens because containers running with the
# default restricted security context (readOnlyRootFilesystem: true,
# capabilities.drop: ALL) cannot raise the buffer beyond ~2x the default
# — far below the 7 MiB quic-go needs.
#
# The fix requires TWO parts:
#
#   1. Raise the kernel limit BEFORE EdgeQuota starts — so that the
#      setsockopt(SO_RCVBUF) syscall can actually succeed.
#
#   2. Set h3UdpReceiveBufferSize / h3UdpSendBufferSize in the transport
#      config below — so EdgeQuota requests the correct buffer size when
#      creating the QUIC socket.
#
# There are three ways to accomplish part 1. Choose ONE:
#
# ── Option A: Privileged init container (recommended) ──────────────────
# A small init container runs "sysctl -w" before EdgeQuota starts. This
# works on any cluster that allows privileged containers and does NOT
# require kubelet configuration changes. The sysctl is namespaced, so it
# only affects this pod's network namespace.
#
# Example:
#   initContainers:
#     - name: sysctl-udp-buffers
#       image: busybox:1.37
#       command:
#         - sh
#         - -c
#         - |
#           sysctl -w net.core.rmem_max=7500000
#           sysctl -w net.core.wmem_max=7500000
#       securityContext:
#         privileged: true
#
# ── Option B: Pod-level sysctls (see "sysctls" above) ─────────────────
# Uses securityContext.sysctls on the pod spec. Cleaner than an init
# container, but requires the kubelet to be started with:
#   --allowed-unsafe-sysctls=net.core.rmem_max,net.core.wmem_max
# This may not be available on managed Kubernetes services.
#
# ── Option C: Node-level tuning ───────────────────────────────────────
# Set the sysctl on the nodes themselves via a DaemonSet, cloud-init, or
# the node OS configuration. This affects ALL pods on the node and does
# not require any pod-level changes, but requires node access.
#
# After choosing one of the above, also set the transport buffer sizes:
#   edgequota.backend.transport.h3UdpReceiveBufferSize: 7500000
#   edgequota.backend.transport.h3UdpSendBufferSize: 7500000
# ============================================================================
initContainers: []
# -- Sidecar containers
sidecars: []

# =============================================================================
# EdgeQuota Application Configuration
# =============================================================================
# These values are rendered into the ConfigMap as config.yaml.
# All durations are Go-style strings (e.g., "30s", "5m", "1h").
edgequota:

  # --- Server (proxy listener) ---
  server:
    # -- Proxy listen port
    port: 8080
    # -- HTTP read timeout
    readTimeout: "30s"
    # -- HTTP write timeout
    writeTimeout: "30s"
    # -- Connection idle timeout
    idleTimeout: "120s"
    # -- Graceful shutdown drain timeout
    drainTimeout: "30s"
    # -- Per-request timeout (0 = no timeout)
    requestTimeout: ""
    # -- Max concurrent in-flight requests. Excess requests receive 503. (0 = unlimited)
    maxConcurrentRequests: 0
    # -- WebSocket Origin header allowlist. Empty = allow all origins.
    allowedWebsocketOrigins: []
    # -- Max WebSocket connections per rate-limit key (0 = unlimited)
    maxWebsocketConnsPerKey: 0
    # -- Max bytes transferred per WebSocket direction (0 = unlimited)
    maxWebsocketTransferBytes: 0
    # -- WebSocket idle timeout — close connections with no activity
    websocketIdleTimeout: ""

    tls:
      # -- Enable TLS on the proxy listener
      enabled: false
      # -- Use an existing TLS secret (e.g., created by cert-manager)
      existingSecret: ""
      # -- Minimum TLS version ("1.2" or "1.3")
      minVersion: ""
      # -- Enable HTTP/3 (QUIC) — requires TLS
      http3Enabled: false
      # -- Port to advertise in Alt-Svc header for HTTP/3 discovery.
      # Set this to the external-facing port (e.g. 443) when running behind
      # a Service or load balancer. 0 = use the container's listen port.
      http3AdvertisePort: 0

  # --- Admin server ---
  admin:
    # -- Admin listen port
    port: 9090
    # -- Admin read timeout
    readTimeout: "5s"
    # -- Admin write timeout
    writeTimeout: "10s"
    # -- Admin idle timeout
    idleTimeout: "30s"

  # --- Backend (upstream) ---
  backend:
    # -- Default backend URL. Required unless external rate-limit mode is used
    # (in which case the external service provides per-request backend_url).
    # Example: "http://my-service.default.svc.cluster.local:8080"
    url: ""
    # -- Request timeout to backend
    timeout: "30s"
    # -- Maximum idle connections
    maxIdleConns: 100
    # -- Idle connection timeout
    idleConnTimeout: "90s"
    # -- Skip TLS verification for backend
    tlsInsecureSkipVerify: false
    # -- Max request body size in bytes (0 = unlimited)
    maxRequestBodySize: 0
    # -- Backend transport tuning
    transport:
      # -- Backend protocol for non-gRPC traffic (auto | h1 | h2 | h3).
      # "auto" probes the static backend via TLS ALPN at startup; for dynamic
      # backends (no static URL) it defaults to h1 since targets vary per-request.
      # gRPC always uses h2 regardless of this setting.
      # Can be overridden per-request by the external rate-limit service via the
      # "backend_protocol" field in the GetLimitsResponse.
      #
      # IMPORTANT: Setting this to "h3" requires raising the kernel UDP buffer
      # limits. Without this, QUIC connections will time out and produce 502s.
      # See the "HTTP/3 backend — UDP buffer prerequisites" section under
      # initContainers above for setup instructions. You must ALSO set
      # h3UdpReceiveBufferSize and h3UdpSendBufferSize below.
      backendProtocol: "auto"
      dialTimeout: ""
      dialKeepAlive: ""
      tlsHandshakeTimeout: ""
      h2ReadIdleTimeout: ""
      expectContinueTimeout: ""
      h2PingTimeout: ""
      websocketDialTimeout: ""
      # -- UDP receive buffer size (bytes) for the QUIC backend socket (SO_RCVBUF).
      # quic-go needs at least 7340032 bytes (~7 MiB). The recommended value is
      # 7500000 (matches the quic-go wiki). This setting tells EdgeQuota what
      # buffer size to request from the kernel. The kernel will silently cap it
      # at net.core.rmem_max, so you MUST also raise that limit via an init
      # container, pod sysctls, or node-level tuning. See the "HTTP/3 backend —
      # UDP buffer prerequisites" section under initContainers for details.
      # 0 = let quic-go manage buffers internally (it will attempt ~7 MiB and
      # log a warning if the kernel caps it lower).
      h3UdpReceiveBufferSize: 0
      # -- UDP send buffer size (bytes) for the QUIC backend socket (SO_SNDBUF).
      # Same considerations as h3UdpReceiveBufferSize; the kernel caps this at
      # net.core.wmem_max. 0 = let quic-go manage buffers internally.
      h3UdpSendBufferSize: 0
    # -- URL policy for dynamic backend URLs (SSRF protection)
    urlPolicy:
      # -- Allowed URL schemes. Default: ["http", "https"]
      allowedSchemes: []
      # -- Block RFC 1918, loopback, link-local, and cloud metadata IPs. Default: true
      denyPrivateNetworks: true
      # -- Optional host allowlist (exact match, case-insensitive). Empty = allow all
      allowedHosts: []

  # --- Redis ---
  redis:
    # -- Redis endpoint(s); list of host:port strings
    endpoints:
      - "localhost:6379"
    # -- Redis mode: single, replication, sentinel, cluster
    mode: "single"
    # -- Redis Sentinel master name (required for sentinel mode)
    masterName: ""
    # -- Redis database number
    db: 0
    # -- Connection pool size
    poolSize: 10
    # -- Dial timeout
    dialTimeout: "5s"
    # -- Read timeout
    readTimeout: "3s"
    # -- Write timeout
    writeTimeout: "3s"
    tls:
      # -- Enable TLS for Redis connections
      enabled: false
      # -- Skip TLS verification
      insecureSkipVerify: false

  # --- Response Cache Redis (optional dedicated instance) ---
  # Dedicated Redis for the CDN-style response cache.
  # Fallback resolution order: response_cache_redis → cache_redis → main redis.
  # Leave endpoints empty to share the main Redis (default).
  # Credentials are set via secrets.responseCacheRedis* fields.
  responseCacheRedis:
    # -- Response cache Redis endpoint(s). Empty = use main Redis (or cache_redis if set).
    endpoints: []
    # -- Redis mode: single, replication, sentinel, cluster
    mode: "single"
    # -- Sentinel master name (required for sentinel mode)
    masterName: ""
    # -- Redis database number
    db: 0
    # -- Connection pool size
    poolSize: 10
    # -- Dial timeout
    dialTimeout: "5s"
    # -- Read timeout
    readTimeout: "3s"
    # -- Write timeout
    writeTimeout: "3s"
    tls:
      # -- Enable TLS for response cache Redis connections
      enabled: false
      # -- Skip TLS verification (not recommended in production)
      insecureSkipVerify: false

  # --- Cache Redis (optional dedicated instance for external RL cache) ---
  # Dedicated Redis for caching external rate-limit service responses.
  # When not enabled, EdgeQuota shares the main Redis for RL caching.
  # NOTE: This is for the *external rate-limit response cache* only.
  # For the CDN-style response cache, use responseCacheRedis above.
  cacheRedis:
    # -- Enable a separate Redis for external rate-limit cache
    enabled: false
    # -- Cache Redis endpoint(s); list of host:port strings
    endpoints: []
    # -- Redis mode: single, replication, sentinel, cluster
    mode: "single"
    # -- Sentinel master name (required for sentinel mode)
    masterName: ""
    # -- Redis database number
    db: 0
    # -- Connection pool size
    poolSize: 10
    # -- Dial timeout
    dialTimeout: "5s"
    # -- Read timeout
    readTimeout: "3s"
    # -- Write timeout
    writeTimeout: "3s"
    tls:
      # -- Enable TLS for cache Redis connections
      enabled: false
      # -- Skip TLS verification (not recommended in production)
      insecureSkipVerify: false

  # =============================================================================
  # CDN-style Response Cache
  # =============================================================================
  # When enabled, EdgeQuota acts as a reverse-proxy cache (like a CDN). Upstream
  # responses are cached in Redis and served on subsequent requests without
  # touching the backend, as long as Cache-Control headers permit it.
  #
  # ── How caching works ──────────────────────────────────────────────────
  # Backends opt in to caching by returning standard HTTP Cache-Control headers:
  #   Cache-Control: public, max-age=300     → cache for 5 minutes
  #   Cache-Control: no-store                → never cache
  #   Cache-Control: private                 → never cache
  #
  # Only GET requests and 200/301 responses are ever cached. POST, PUT, PATCH,
  # DELETE, WebSocket, gRPC, and SSE traffic bypasses the cache entirely.
  #
  # The cache key is: method | path | query | Vary-header-values
  # (headers not listed in the upstream's Vary response header are ignored).
  #
  # ── Cache invalidation via admin API ───────────────────────────────────
  # POST /v1/cache/purge        { "url": "/path", "method": "GET" }
  # POST /v1/cache/purge/tags   { "tags": ["product-123", "category-shoes"] }
  #
  # Tags are set by backends via the Surrogate-Key or Cache-Tag response header:
  #   Surrogate-Key: product-123 category-shoes
  #
  # ── Redis configuration ─────────────────────────────────────────────────
  # The response cache uses, in priority order:
  #   1. responseCacheRedis  (dedicated cluster, if endpoints are set)
  #   2. cacheRedis          (shared ext-RL cache Redis, if enabled)
  #   3. main redis          (fallback)
  #
  # For high-traffic caches, a dedicated Redis instance (responseCacheRedis)
  # is recommended to avoid contention with rate-limit counters.
  #
  # ── Example: enable for static assets ──────────────────────────────────
  #   cache:
  #     enabled: true
  #     maxBodySize: "5MB"
  #
  # ── Example: with dedicated Redis ──────────────────────────────────────
  #   cache:
  #     enabled: true
  #     maxBodySize: "10MB"
  #   responseCacheRedis:
  #     endpoints:
  #       - "cdn-redis:6379"
  #     mode: "single"
  #     poolSize: 50
  # =============================================================================
  cache:
    # -- Enable the CDN-style response cache
    enabled: false
    # -- Maximum response body size to cache. Responses larger than this are
    # passed through without caching. Human-readable: "512KB", "1MB", "10MB".
    maxBodySize: "1MB"

  # --- Rate Limiting ---
  #
  # Rate limiting has two modes:
  #
  # 1. STATIC ONLY (default) -- EdgeQuota enforces fixed average/burst/period
  #    limits, extracting the rate-limit key locally (by client IP, header, etc).
  #    Configure `rateLimit.static.*`.
  #
  # 2. EXTERNAL RL -- EdgeQuota delegates quota resolution to an external
  #    service. The external service decides the limits per request. EdgeQuota
  #    skips local key extraction. The request sent to the external service
  #    contains only headers, method, and path (no key field).
  #    Configure `rateLimit.external.*`.
  #    When the external service is unavailable, EdgeQuota falls back to the
  #    limits defined in `rateLimit.external.fallback.*`.
  #
  # ── Example A: Static rate limiting (per-IP) ────────────────────────
  #   rateLimit:
  #     static:
  #       average: 100
  #       burst: 50
  #       period: "1s"
  #       keyStrategy:
  #         type: "clientIP"
  #
  # ── Example B: External RL for FE/static assets ─────────────────────
  #   rateLimit:
  #     external:
  #       enabled: true
  #       http:
  #         url: "http://limits-service:8080/limits"
  #       fallback:
  #         average: 5000
  #         burst: 2000
  #         period: "1s"
  #         keyStrategy:
  #           type: "global"
  #           globalKey: "fe-assets"
  #
  # ── Example C: External RL with per-tenant header fallback ──────────
  #   rateLimit:
  #     external:
  #       enabled: true
  #       http:
  #         url: "http://limits-service:8080/limits"
  #       fallback:
  #         average: 100
  #         burst: 50
  #         period: "1s"
  #         keyStrategy:
  #           type: "header"
  #           headerName: "X-Tenant-Id"
  #
  # NOTE: External RL and auth response caching share the same priority order:
  #   1. HTTP Cache-Control: max-age=N  (highest priority)
  #   2. HTTP Expires: <date>
  #   3. Body field cache_max_age_seconds
  #   4. Body field cache_no_store: true
  # HTTP headers always win over body fields. No default TTL is applied —
  # the external service must explicitly opt in to caching. Ephemeral headers
  # (tracing IDs, X-Request-Id, etc.) are automatically excluded from cache keys.
  #
  rateLimit:
    # -- Failure policy: passThrough, failClosed, inMemoryFallback
    failurePolicy: "passThrough"
    # -- HTTP status code on rate limit (4xx or 5xx)
    failureCode: 429
    # -- Redis key prefix
    keyPrefix: ""
    # -- Minimum Redis key TTL
    minTTL: ""
    # -- Max distinct tenant label values for per-tenant metrics (0 = default 1000)
    maxTenantLabels: 0
    # -- Max Redis recovery attempts before giving up (0 = unlimited)
    maxRecoveryAttempts: 0
    # -- Global RPS safety valve for passthrough mode (0 = disabled)
    globalPassthroughRps: 0

    # -- Static rate-limit bucket parameters.
    # Used when external RL is DISABLED. Ignored when external RL is enabled.
    static:
      # -- Requests per period (0 = disabled / passthrough)
      average: 0
      # -- Burst capacity
      burst: 1
      # -- Time period for the rate limit
      period: "1s"
      # -- Key extraction strategy
      keyStrategy:
        # -- Strategy type: clientIP, header, composite, global
        #    clientIP  -- rate limit by client IP (default)
        #    header    -- rate limit by a request header (requires headerName)
        #    composite -- header + first path segment (requires headerName)
        #    global    -- fixed key, all requests share one bucket
        type: "clientIP"
        # -- Header name (required for header/composite)
        headerName: ""
        # -- Include path prefix in composite key
        pathPrefix: false
        # -- Fixed key for global strategy (defaults to "global" when empty)
        globalKey: ""
        # -- Trusted proxy CIDRs for X-Forwarded-For
        trustedProxies: []
        # -- X-Forwarded-For depth to use (0 = leftmost, N = Nth from right)
        trustedIPDepth: 0

    # -- External rate-limit service configuration.
    # When enabled, EdgeQuota delegates quota resolution to an external service.
    # Key extraction is skipped; the external service derives keys from
    # headers, Host, and path.
    external:
      # -- Enable external rate-limit service
      enabled: false
      # -- Failure policy when external RL is unreachable: passthrough, failclosed
      failurePolicy: "passthrough"
      # -- Request timeout
      timeout: "5s"

      # -- Fallback rate-limit parameters when the external RL service is
      # unavailable. REQUIRED when external.enabled is true.
      # Defines the safety-net limits applied during external service outages.
      fallback:
        # -- Fallback requests per period (REQUIRED, must be > 0)
        average: 0
        # -- Fallback burst capacity
        burst: 1
        # -- Fallback time period
        period: "1s"
        # -- Fallback key extraction strategy.
        # Recommended: "global" for FE/static assets (no custom headers),
        #              "header" or "clientIP" for backend APIs.
        keyStrategy:
          type: "global"
          headerName: ""
          pathPrefix: false
          globalKey: "fallback"
          trustedProxies: []
          trustedIPDepth: 0

      http:
        # -- External RL HTTP URL
        url: ""
      grpc:
        # -- External RL gRPC address
        address: ""
        tls:
          # -- Enable TLS for external RL gRPC
          enabled: false
          # -- CA file for TLS verification
          caFile: ""
          # -- Override TLS server name
          serverName: ""
      # -- Header filter for requests to external RL service.
      # Controls which headers are SENT to the external service (security concern).
      headerFilter:
        # -- Allow only these headers (takes precedence over denyList)
        allowList: []
        # -- Deny these headers
        denyList: []
      # -- Max concurrent in-flight requests (0 = default 50)
      maxConcurrentRequests: 0
      # -- Max per-tenant circuit breaker entries (0 = default 10000)
      maxCircuitBreakers: 0
      # -- Max acceptable latency before tripping circuit breaker
      maxLatency: ""
      # -- Circuit breaker settings for external RL
      circuitBreaker:
        # -- Failures before opening circuit (0 = default 5)
        threshold: 0
        # -- Time before half-open retry
        resetTimeout: ""

  # --- Auth (optional) ---
  auth:
    # -- Enable external auth
    enabled: false
    # -- Auth request timeout
    timeout: "5s"
    # -- Auth failure policy: failclosed, passthrough
    failurePolicy: "failclosed"
    # -- Forward the original request body to the auth service
    propagateRequestBody: false
    # -- Max body size to forward to auth (bytes, 0 = unlimited)
    maxAuthBodySize: 0
    http:
      # -- Auth HTTP URL
      url: ""
      # -- Forward original request headers to auth HTTP service
      forwardOriginalHeaders: false
    grpc:
      # -- Auth gRPC address
      address: ""
      tls:
        # -- Enable TLS for auth gRPC
        enabled: false
        # -- CA file for auth gRPC TLS
        caFile: ""
        # -- Override TLS server name for auth gRPC
        serverName: ""
    # -- Header filter for requests to auth service.
    # Default (both lists empty): DefaultAuthDenyHeaders deny-list applies —
    # Cookie, Set-Cookie, Proxy-Authorization, Proxy-Authenticate, X-Csrf-Token,
    # and X-Xsrf-Token are stripped; everything else (Authorization, X-Api-Key,
    # X-Tenant-Id, Content-Type, custom headers...) is forwarded.
    # This differs from the external RL default which also strips Authorization
    # and X-Api-Key — the auth service needs those to validate credentials.
    #
    # To restrict to an explicit allow-list:
    #   allowList: ["Authorization", "X-Tenant-Id"]
    #
    # To replace the deny-list:
    #   denyList: ["Cookie", "Set-Cookie", "X-Internal-Secret"]
    #
    # allowList takes precedence over denyList when both are set.
    headerFilter:
      # -- Allow only these headers (takes precedence over denyList).
      # Empty = use DefaultAuthDenyHeaders (see above).
      allowList: []
      # -- Deny these headers. Only applied when allowList is empty.
      # Empty = use DefaultAuthDenyHeaders (see above).
      denyList: []
    # -- Headers the auth service is allowed to inject into the proxied request.
    # Only these header names (case-insensitive) will be forwarded from the
    # auth response to the upstream backend. Empty = no injection.
    allowedInjectionHeaders: []
    # -- Circuit breaker for auth service
    circuitBreaker:
      # -- Failures before opening circuit (0 = default)
      threshold: 0
      # -- Time before half-open retry
      resetTimeout: ""

  # --- Events (optional usage event emission) ---
  events:
    # -- Enable usage event emission
    enabled: false
    http:
      # -- Events HTTP webhook URL
      url: ""
      # -- Custom headers attached to every events HTTP request.
      # Values are treated as secrets (redacted in logs and /v1/config).
      # Restricted headers (Host, Content-Type, Content-Length, etc.) are rejected.
      headers: {}
      # Example:
      #   headers:
      #     Authorization: "Bearer my-token"
      #     X-Source: "edgequota"
    grpc:
      # -- Events gRPC address
      address: ""
      tls:
        # -- Enable TLS for events gRPC
        enabled: false
        # -- CA file for TLS verification
        caFile: ""
        # -- Override TLS server name
        serverName: ""
    # -- Number of events per batch
    batchSize: 0
    # -- Flush interval for event batches
    flushInterval: ""
    # -- Internal event buffer size
    bufferSize: 0
    # -- Max send retries per batch before dropping (0 = default 3)
    maxRetries: 0
    # -- Initial retry backoff (doubles per attempt)
    retryBackoff: ""
    # -- Header filter for events payload
    headerFilter:
      # -- Allow only these headers
      allowList: []
      # -- Deny these headers
      denyList: []

  # --- Logging ---
  logging:
    # -- Log level: debug, info, warn, error
    level: "info"
    # -- Log format: json, text
    format: "json"
    # -- Emit per-request access logs (method, path, status, duration, etc.)
    accessLogEnabled: true

  # --- Tracing (optional) ---
  tracing:
    # -- Enable OpenTelemetry tracing
    enabled: false
    # -- OTLP endpoint
    endpoint: ""
    # -- Service name for traces
    serviceName: "edgequota"
    # -- Sampling rate (0.0 to 1.0)
    sampleRate: 0.1

  # -- Extra config entries appended to the ConfigMap data section
  extraConfig: {}
